abstract Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode! nameSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Microsoft.CodeAnalysis.AliasInfo
abstract Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(int position, Microsoft.CodeAnalysis.SyntaxNode! nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) -> Microsoft.CodeAnalysis.AliasInfo
Microsoft.CodeAnalysis.AliasInfo
Microsoft.CodeAnalysis.AliasInfo.Alias.get -> Microsoft.CodeAnalysis.IAliasSymbol?
Microsoft.CodeAnalysis.AliasInfo.AliasInfo() -> void
Microsoft.CodeAnalysis.AliasInfo.Equals(Microsoft.CodeAnalysis.AliasInfo other) -> bool
Microsoft.CodeAnalysis.AliasInfo.Target.get -> Microsoft.CodeAnalysis.INamespaceOrTypeSymbol?
Microsoft.CodeAnalysis.AliasMap
Microsoft.CodeAnalysis.AliasMap.AliasMap(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IAliasSymbol!> aliasSymbols) -> void
Microsoft.CodeAnalysis.AliasMap.TryGetAlias(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol! symbol, out Microsoft.CodeAnalysis.IAliasSymbol? aliasSymbol, out System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol!> typeArguments, bool mustResolveAllTypeParameters = true) -> bool
Microsoft.CodeAnalysis.CommandLineArguments.FriendAccessibleAssemblies.get -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CommandLineAssemblyIdentity>
Microsoft.CodeAnalysis.CommandLineAssemblyIdentity
Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.CommandLineAssemblyIdentity() -> void
Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.CommandLineAssemblyIdentity(string! name, System.Collections.Immutable.ImmutableArray<byte> publicKey) -> void
Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.Equals(Microsoft.CodeAnalysis.CommandLineAssemblyIdentity other) -> bool
Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.Name.get -> string!
Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.PublicKey.get -> System.Collections.Immutable.ImmutableArray<byte>
Microsoft.CodeAnalysis.CompilationOptions.FriendAccessibleAssemblyPublicKeys.get -> System.Collections.Immutable.ImmutableDictionary<string!, System.Collections.Immutable.ImmutableHashSet<System.Collections.Immutable.ImmutableArray<byte>>!>!
Microsoft.CodeAnalysis.Emit.RuntimeRudeEdit.ErrorCode.get -> int
Microsoft.CodeAnalysis.Emit.RuntimeRudeEdit.RuntimeRudeEdit(string! message, int errorCode) -> void
Microsoft.CodeAnalysis.GeneratorDriver.RunGenerators(Microsoft.CodeAnalysis.Compilation! compilation) -> Microsoft.CodeAnalysis.GeneratorDriver!
Microsoft.CodeAnalysis.GeneratorDriver.RunGenerators(Microsoft.CodeAnalysis.Compilation! compilation, System.Func<Microsoft.CodeAnalysis.GeneratorFilterContext, bool>? generatorFilter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Microsoft.CodeAnalysis.GeneratorDriver!
Microsoft.CodeAnalysis.GeneratorDriver.RunGenerators(Microsoft.CodeAnalysis.Compilation! compilation, System.Threading.CancellationToken cancellationToken) -> Microsoft.CodeAnalysis.GeneratorDriver!
*REMOVED*Microsoft.CodeAnalysis.GeneratorDriver.RunGenerators(Microsoft.CodeAnalysis.Compilation! compilation, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Microsoft.CodeAnalysis.GeneratorDriver!
Microsoft.CodeAnalysis.GeneratorDriverOptions.BaseDirectory.get -> string?
Microsoft.CodeAnalysis.GeneratorDriverOptions.GeneratorDriverOptions(Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind disabledOutputs = Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind.None, bool trackIncrementalGeneratorSteps = false, string? baseDirectory = null) -> void
Microsoft.CodeAnalysis.GeneratorFilterContext
Microsoft.CodeAnalysis.GeneratorFilterContext.CancellationToken.get -> System.Threading.CancellationToken
Microsoft.CodeAnalysis.GeneratorFilterContext.Generator.get -> Microsoft.CodeAnalysis.ISourceGenerator!
Microsoft.CodeAnalysis.GeneratorFilterContext.GeneratorFilterContext() -> void
Microsoft.CodeAnalysis.GeneratorRunResult.HostOutputs.get -> System.Collections.Immutable.ImmutableDictionary<string!, object!>!
Microsoft.CodeAnalysis.IAliasSymbol.Arity.get -> int
Microsoft.CodeAnalysis.IAliasSymbol.Construct(params Microsoft.CodeAnalysis.ITypeSymbol![]! typeArguments) -> Microsoft.CodeAnalysis.ITypeSymbol!
Microsoft.CodeAnalysis.IAliasSymbol.Construct(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol!> typeArguments, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.NullableAnnotation> typeArgumentNullableAnnotations) -> Microsoft.CodeAnalysis.ITypeSymbol!
Microsoft.CodeAnalysis.IAliasSymbol.IsGenericAlias.get -> bool
Microsoft.CodeAnalysis.IAliasSymbol.TypeParameters.get -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeParameterSymbol!>
Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind.Host = 8 -> Microsoft.CodeAnalysis.IncrementalGeneratorOutputKind
Microsoft.CodeAnalysis.IncrementalGeneratorPostInitializationContext.AddEmbeddedAttributeDefinition() -> void
Microsoft.CodeAnalysis.IPropertySymbol.PartialDefinitionPart.get -> Microsoft.CodeAnalysis.IPropertySymbol?
Microsoft.CodeAnalysis.IPropertySymbol.PartialImplementationPart.get -> Microsoft.CodeAnalysis.IPropertySymbol?
Microsoft.CodeAnalysis.IPropertySymbol.IsPartialDefinition.get -> bool
Microsoft.CodeAnalysis.ITypeParameterSymbol.AllowsRefLikeType.get -> bool
Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringAlias.get -> Microsoft.CodeAnalysis.IAliasSymbol?
Microsoft.CodeAnalysis.NameWithArity
Microsoft.CodeAnalysis.NameWithArity.HasArity.get -> bool
Microsoft.CodeAnalysis.NameWithArity.IsDefault.get -> bool
Microsoft.CodeAnalysis.NameWithArity.NameWithArity() -> void
Microsoft.CodeAnalysis.NameWithArity.NameWithArity(string! name, int arity) -> void
Microsoft.CodeAnalysis.NameWithArity.Parse(string! str) -> Microsoft.CodeAnalysis.NameWithArity
Microsoft.CodeAnalysis.NameWithArityComparer
Microsoft.CodeAnalysis.NameWithArityComparer.Compare(Microsoft.CodeAnalysis.NameWithArity x, Microsoft.CodeAnalysis.NameWithArity y) -> int
Microsoft.CodeAnalysis.NameWithArityComparer.Equals(Microsoft.CodeAnalysis.NameWithArity x, Microsoft.CodeAnalysis.NameWithArity y) -> bool
Microsoft.CodeAnalysis.NameWithArityComparer.GetHashCode(Microsoft.CodeAnalysis.NameWithArity obj) -> int
Microsoft.CodeAnalysis.NameWithArityComparer.NameWithArityComparer(System.StringComparer! nameComparer) -> void
Microsoft.CodeAnalysis.NameWithArityComparer.Underlying.get -> System.StringComparer!
Microsoft.CodeAnalysis.RuntimeCapability.ByRefLikeGenerics = 8 -> Microsoft.CodeAnalysis.RuntimeCapability
Microsoft.CodeAnalysis.SymbolInfo.AnnotationSymbols.get -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol!>
Microsoft.CodeAnalysis.TypeParameterKind.Alias = 3 -> Microsoft.CodeAnalysis.TypeParameterKind
override Microsoft.CodeAnalysis.AliasInfo.Equals(object? obj) -> bool
override Microsoft.CodeAnalysis.AliasInfo.GetHashCode() -> int
override Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.Equals(object? obj) -> bool
override Microsoft.CodeAnalysis.CommandLineAssemblyIdentity.GetHashCode() -> int
override Microsoft.CodeAnalysis.NameWithArity.GetHashCode() -> int
override Microsoft.CodeAnalysis.NameWithArity.ToString() -> string!
readonly Microsoft.CodeAnalysis.NameWithArity.Arity -> int
readonly Microsoft.CodeAnalysis.NameWithArity.Name -> string!
static Microsoft.CodeAnalysis.GeneratorExtensions.AsIncrementalGenerator(this Microsoft.CodeAnalysis.ISourceGenerator! sourceGenerator) -> Microsoft.CodeAnalysis.IIncrementalGenerator!
static Microsoft.CodeAnalysis.GeneratorExtensions.GetGeneratorType(this Microsoft.CodeAnalysis.IIncrementalGenerator! generator) -> System.Type!
Microsoft.CodeAnalysis.Compilation.CreatePreprocessingSymbol(string! name) -> Microsoft.CodeAnalysis.IPreprocessingSymbol!
static Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfoWithTarget(this Microsoft.CodeAnalysis.SemanticModel! semanticModel, Microsoft.CodeAnalysis.SyntaxNode! nameSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> Microsoft.CodeAnalysis.AliasInfo
static Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(this Microsoft.CodeAnalysis.SemanticModel! semanticModel, int position, Microsoft.CodeAnalysis.SyntaxNode! nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) -> Microsoft.CodeAnalysis.AliasInfo
static Microsoft.CodeAnalysis.NameWithArity.implicit operator Microsoft.CodeAnalysis.NameWithArity(string? name) -> Microsoft.CodeAnalysis.NameWithArity
static Microsoft.CodeAnalysis.NameWithArityComparer.Default.get -> Microsoft.CodeAnalysis.NameWithArityComparer!
static Microsoft.CodeAnalysis.NameWithArityComparer.IgnoreCase.get -> Microsoft.CodeAnalysis.NameWithArityComparer!
static readonly Microsoft.CodeAnalysis.AliasInfo.None -> Microsoft.CodeAnalysis.AliasInfo
static readonly Microsoft.CodeAnalysis.AliasMap.Empty -> Microsoft.CodeAnalysis.AliasMap!
[RSEXPERIMENTAL004]Microsoft.CodeAnalysis.HostOutputProductionContext
[RSEXPERIMENTAL004]Microsoft.CodeAnalysis.HostOutputProductionContext.AddOutput(string! name, object! value) -> void
[RSEXPERIMENTAL004]Microsoft.CodeAnalysis.HostOutputProductionContext.CancellationToken.get -> System.Threading.CancellationToken
[RSEXPERIMENTAL004]Microsoft.CodeAnalysis.HostOutputProductionContext.HostOutputProductionContext() -> void
[RSEXPERIMENTAL004]Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterHostOutput<TSource>(Microsoft.CodeAnalysis.IncrementalValueProvider<TSource> source, System.Action<Microsoft.CodeAnalysis.HostOutputProductionContext, TSource>! action) -> void
[RSEXPERIMENTAL004]Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext.RegisterHostOutput<TSource>(Microsoft.CodeAnalysis.IncrementalValuesProvider<TSource> source, System.Action<Microsoft.CodeAnalysis.HostOutputProductionContext, TSource>! action) -> void
